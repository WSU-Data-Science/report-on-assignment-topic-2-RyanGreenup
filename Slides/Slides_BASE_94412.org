#+TITLE: Math with Computers
:PREAMBLE:
#+OPTIONS: broken-links:auto todo:nil H:9
#+STARTUP: content
#+OPTIONS: tags:not-in-toc d:nil
#+AUTHOR: Ryan Greenup & James Guerra
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
# #+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: TAD
:END:
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css">
# #+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:R:
#+PROPERTY: header-args:R :session TADMain :dir ./ :cache yes :eval never-export :exports both
#+PROPERTY: :eval never-export
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:LATEX:
#+LATEX_HEADER: \IfFileExists{../resources/style.sty}{\usepackage{../resources/style}}{}
#+LATEX_HEADER: \IfFileExists{../resources/referencing.sty}{\usepackage{../resources/referencing}}{}
#+LATEX_HEADER: \addbibresource{./bibtex-refs.bib}
:END:
:REVEAL:
#+REVEAL_THEME: sky
:END:

* Follow along

Scan the QR Code with your phone to follow along!

# #+NAME: qcode
# #+CAPTION: Export Relevant link as a QR Code.
#+begin_src bash :exports both :results output graphics file :file qrcode.png :eval never-export
qrencode -o qrcode.png \
    "https://ryangreenup.github.io/Python-Quant/Outline/Slides/Slides.html"
#    "http://ryansnotes.org/x/00Slides/Slides/Slides.html"
#+end_src


#+attr_html: :width 400px
#+attr_latex: :width 9cm
[[file:qrcode.png]]



* Introduction
** What we are doing (ish)
Our title is vague because our project is broad, which is awesome!

We are looking at the concept of computational thinking:

- How to solve mathematical problems computationally
- Investigating the methods implemented by other /Computer Algebra Software/
  (CAS)
  + With a primary focus on FOSS and Modern technologies (like /Sympyüêç/ and
    /Julia/)
- Investigate patterns, fractals, chaos and dynamical systems.

** Technologies


+---------------------------------------------------+-------------+
| CAS Systems                                       |Visualisation|
+--------------------------------------+------------+-------------+
|      Python                          | Maxima     |    Makie    |
|          - Sympy                     | Reduce     |    Plotly   |
|          - Numpy                     | XCas/Gias  |    GNUPlot  |
|       Julia                          |            |             |
|          - SymEngine                 |            |             |
|          - Symata                    |            |             |
|          - DifferentialEquations.jl  |            |             |
+--------------------------------------+------------+-------------+

#+begin_export html
<p><img src="https://www.sympy.org/static/images/logo.png" width="50"/>
    <img src="https://julialang.org/assets/infra/logo.svg" width="50"/>
    <img src="https://makie.juliaplots.org/stable/assets/logo.png" width="50"/>
    <img src="https://numpy.org/images/logos/numpy.svg" width="50"/>
    <img src="https://www-fourier.ujf-grenoble.fr/~parisse/logo.png" width="50"/>
    <img src="http://maxima.sourceforge.net/i/logo.png"/></p>
#+end_export


** Some open Questions

Some of the problems that we wanted to work on:

+ Can we model the patterns on animals?
+ What is the relationship between Julia Sets, the Cantor set, the lorenz attractor and structures in nature.
+ Can Julia Sets be extended to the quaternions
+ Can we simulate things like the spiral of a nautilus shell?
  - How is this related to the Fibonacci Sequence and $\phi$

** Motivation

Many problems that look complex upon initial inspection can be solved trivially
with CAS systems, learning how to effectively approach problems with that in
mind can lead to new insights.

*** Iteration and Recursion
**** Series
   :PROPERTIES:
   :CUSTOM_ID: series-and-recursion
   :END:
Consider the following two series
\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4}  \ldots \label{eq:rec-ser}
\end{align}

let's modify this for the sake of discussion:

\begin{align}
h\left( k \right) = \frac{\sqrt{2}  }{2} \cdot  \frac{\sqrt{3 +  \sqrt{2} } }{3} \cdot  \frac{\sqrt{4 +  \sqrt{3 +  \sqrt{2} } } }{4} \ldots   \label{eq:rec-ser-mod}
\end{align}

**** Recursion
This can be expressed with recursion:

#+NAME: rec-one
#+BEGIN_SRC python
from sympy import *
def h(k):
    if k > 2:
        return f(k) * f(k-1)
    else:
        return 1

def f(i):
    expr = 0
    if i > 2:
        return sqrt(i + f(i -1))
    else:
        return 1
#+END_SRC

**** Iteration
Another approach is iteration.

#+NAME: it-one
#+BEGIN_SRC python
  from sympy import *
  def h(k):
      k = k + 1 # OBOB
      l = [f(i) for i in range(1,k)]
      return prod(l)

  def f(k):
      expr = 0
      for i in range(2, k+2):
          expr = sqrt(i + expr, evaluate=False)
      return expr/(k+1)
#+END_SRC

**** Recursion or Iteration

- Any function that can be defined by using iteration, can always be defined via
  recursion and vice versa
#+begin_notes
- Evidence suggests that recursive functions are easier for people to understand
  - Although independent research has shown that the specific language chosen can be more important.
- Not sure if this is true for would be true for compiled languages such as
  /Julia/, /Java/, */C/* etc.
- Loops are usually faster because of the overheads involved in creating
  functions
  + Also there are often recursion limits that aren't an issue in iterated methods.
#+end_notes

- For interpreted languages such */R/* and /Python/, loops are usually
  faster.

**** Some Problems are tricky
:PROPERTIES:
    :CUSTOM_ID: some-functions-are-more-difficult-to-express-with-recursion-in-python
    :END:
Attacking a problem recursively isn't always the best approach, consider the
function $g\left( k \right)$ from before:


\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4} \cdot \nonumber \\
\end{align}

- The sequence looks forward not back

#+REVEAL: split

So to implement recursion it must be restructured, however, this can be a bit
clumsy:


\begin{align}
    g\left( k \right) &=  \prod^k_{i = 2} \left( \frac{f_i}{i}  \right) \quad \nonumber \\
& \quad f_{i} = \sqrt{\left( k- i \right)  +  f_{k - i - 1}} \label{eq:clumsy}
\end{align}

***** Solving with Recursion

- $f$ is now two variabled
- This can get very confusing with nested functions because of scope
#+begin_notes
To Implement a recursive definition in /Python/ requires additional variables to be used.

This can get very confusing because */R/* and ~bash~ have a different
implementation of scope than /Python/ and /Julia/!
#+end_notes

#+NAME: rec-two
#+BEGIN_SRC python
from sympy import *
def h(k):
    if k > 2:
        return f(k, k) * f(k, k-1)
    else:
        return 1

def f(k, i):
    if k > i:
        return 1
    if i > 2:
        return sqrt((k-i) + f(k, k - i -1))
    else:
        return 1
#+END_SRC

***** Solving with Iteration
by using ~reversed~ this essentially stays the same.

#+NAME: iter-two
#+BEGIN_SRC python
from sympy import *
def h(k):
    k = k + 1 # OBOB
    l = [f(i) for i in range(1,k)]
    return prod(l)

def f(k):
    expr = 0
    for i in reversed(range(2, k+2)):
        expr = sqrt(i + expr, evaluate=False)
    return expr/(k+1)
#+END_SRC

**** TODO Variable Scope of Nested Functions
:PROPERTIES:
:CUSTOM_ID: variable-scope-nested
:END:
Using Python and Julia can be very confusing if you are used to using
*/R/* and =bash=.
#+begin_notes
- R and bash are concerned with where functions are called
- Python and Julia are concerned with where functions are defined.
#+end_notes

***** Languages that pass variables up to parents
   :PROPERTIES:
   :CUSTOM_ID: languages-that-pass-variables-up-to-parents
   :END:

Functions defined in */R/* and =bash= will /pass/ variables up into
there parent function, for example consider the following:

***** */R/*
   :PROPERTIES:
   :CUSTOM_ID: r
   :END:

#+BEGIN_SRC R
  outer <- function() {
    inner()
    print(x)
  }

  inner <- function() {
    x <- 3
  }

  outer()
#+END_SRC

#+BEGIN_EXAMPLE
  3
#+END_EXAMPLE

***** =bash=
   :PROPERTIES:
   :CUSTOM_ID: bash
   :END:

#+BEGIN_SRC sh
  outer() {
    inner
    echo "${x}"
  }

  inner() {
    x=3
  }

  outer
#+END_SRC

#+BEGIN_EXAMPLE
  3
#+END_EXAMPLE

***** Languages that don't pass variables up to parents
   :PROPERTIES:
   :CUSTOM_ID: languages-that-dont-pass-variables-up-to-parents
   :END:

****** Using Attributes
    :PROPERTIES:
    :CUSTOM_ID: using-attributes
    :END:

whereas in /Python/ you would need to make the variable an attribute of
the function first (I'm not sure if this feature exists in /Julia/?):

#+BEGIN_SRC python
  def outer():
      x = inner()
      print(str(inner.x))

  def inner():
      inner.x = 3

  outer()
#+END_SRC

****** Using Return
    :PROPERTIES:
    :CUSTOM_ID: using-return
    :END:

****** Julia
    :PROPERTIES:
    :CUSTOM_ID: julia
    :END:

#+BEGIN_SRC julia
  function outer()
      x=subfunction()
      print(x)
  end

  function subfunction()
      x=4
      return x
  end

  outer()
#+END_SRC

#+BEGIN_EXAMPLE
  3
#+END_EXAMPLE

***** Julia Scope of =for= loops
   :PROPERTIES:
   :CUSTOM_ID: julia-scope-of-for-loops
   :END:

In Julia observe that the following will not work:

#+BEGIN_SRC julia
i=6
while i < 9
    print(i)
    i = i + 1
end
#+END_SRC

Where as wrapping it in a function will rectify the issue:

#+BEGIN_SRC julia
function blah()
    i=6
    while i < 9
        print(i)
        i = i + 1
    end
end

blah()
#+END_SRC

Odd huh.

* TODO Fibonacci Sequence
** TODO Computational Approach
   :PROPERTIES:
   :CUSTOM_ID: define-the-fibonacci-numbers
   :END:
The /Fibonacci/ Numbers are given by:

\begin{align}
F_n = F_{n-1} + F_{n-2} \label{eq:fib-def}
\end{align}

** Defining Recursively in Python


#+NAME: fib-rec-0
#+BEGIN_SRC python
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require integer values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)
#+END_SRC

#+NAME: time-slow
#+CAPTION: Using the function from listing [[fib-rec-0]] is quite slow.
#+BEGIN_SRC python
  start = time.time()
  rec_fib(35)
  print(str(round(time.time() - start, 3)) + "seconds")

## 2.245seconds
#+END_SRC

** Caching to Memory

#+NAME: fib-cache
#+CAPTION: Caching the results of the function previously defined [[time-slow]]
#+BEGIN_SRC python
  from functools import lru_cache

  @lru_cache(maxsize=9999)
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require Integer Values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)


start = time.time()
rec_fib(35)
print(str(round(time.time() - start, 3)) + "seconds")
## 0.0seconds
#+END_SRC

#+BEGIN_SRC python
  start = time.time()
  rec_fib(6000)
  print(str(round(time.time() - start, 9)) + "seconds")

## 8.3923e-05seconds
#+END_SRC

Restructuring the problem to use iteration will allow for even greater performance as demonstrated by finding $F_{10^{6}}$ in listing [[fib-iter]]. Using a compiled language such as /Julia/ however would be thousands of times faster still, as demonstrated in listing [[julia-fib]].

** Solving Iteratively

#+NAME: fib-iter
#+CAPTION: Using Iteration to Solve the Fibonacci Sequence
#+BEGIN_SRC python
  def my_it_fib(k):
      if k == 0:
          return k
      elif type(k) is not int:
          print("ERROR: Integer Required")
          return 0
      # Hence k must be a positive integer

      i  = 1
      n1 = 1
      n2 = 1

      # if k <=2:
      #     return 1

      while i < k:
         no = n1
         n1 = n2
         n2 = no + n2
         i = i + 1
      return (n1)

  start = time.time()
  my_it_fib(10**6)
  print(str(round(time.time() - start, 9)) + "seconds")

 ## 6.975890398seconds
#+END_SRC

** Solving With Julia is even Faster

#+NAME: julia-fib
#+CAPTION: Using Julia with an iterative approach to solve the 1 millionth fibonacci number
#+begin_src julia :results output
function my_it_fib(k)
    if k == 0
        return k
    elseif typeof(k) != Int
        print("ERROR: Integer Required")
        return 0
    end
    # Hence k must be a positive integer

    i  = 1
    n1 = 1
    n2 = 1

    # if k <=2:
    #     return 1
    while i < k
       no = n1
       n1 = n2
       n2 = no + n2
       i = i + 1
    end
    return (n1)
end

@time my_it_fib(10^6)

##  my_it_fib (generic function with 1 method)
##    0.000450 seconds
#+end_src

In this case however an analytic solution can be found by relating discrete
mathematical problems to continuous ones as discussed below at section
[[#exp-gen-function]].
** Exponential Generating Functions
:PROPERTIES:
:CUSTOM_ID: exp-gen-func-fib-seq
:END:
*** Motivation
    :PROPERTIES:
    :CUSTOM_ID: motivation
    :END:

Consider the /Fibonacci Sequence/ from eqref:eq:fib-def:


\begin{align}
    a_{n}&= a_{n - 1} + a_{n - 2} \nonumber \\
\iff a_{n+  2} &= a_{n+  1} +  a_n \label{eq:fib-def-shift}
\end{align}


from observation, this appears similar in structure to the following /ordinary
differential equation/, which would be fairly easy to deal with:


\begin{align*}
f''\left( x \right)- f'\left( x \right)- f\left( x \right)=  0
\end{align*}


This would imply that $f\left( x \right) \propto e^{mx}, \quad \exists m \in \mathbb{Z}$ because
$\frac{\mathrm{d}\left( e^x \right) }{\mathrm{d} x} = e^x$, and so by using a power series it's quite feasable to move between discrete and continuous problems:


\begin{align*}
f\left( x \right)= e^{rx} = \sum^{\infty}_{n= 0}   \left[ r \frac{x^n}{n!} \right]
\end{align*}

*** Example
    :PROPERTIES:
    :CUSTOM_ID: solving-the-sequence
    :END:

Consider using the following generating function, (the derivative of the
generating function as in eqref:eq:exp-gen-def-2 and eqref:eq:exp-gen-def-3 is
provided in section [[#Derivative-exp-gen-function]])




\begin{alignat}{2}
    f \left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n} \cdot  \frac{x^n}{n!} \right]   &= e^x \label{eq:exp-gen-def-1} \\
    f'\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+1} \cdot  \frac{x^n}{n!} \right]  &= e^x  \label{eq:exp-gen-def-2} \\
    f''\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+2} \cdot  \frac{x^n}{n!} \right] &= e^x  \label{eq:exp-gen-def-3}
\end{alignat}


So the recursive relation from eqref:eq:fib-def-shift  could be expressed :


\begin{align*}
a_{n+  2}    &= a_{n+  1} +  a_{n}\\
\frac{x^n}{n!}   a_{n+  2}    &= \frac{x^n}{n!}\left( a_{n+  1} +  a_{n}  \right)\\
\sum^{\infty}_{n= 0} \left[ \frac{x^n}{n!}   a_{n+  2} \right]        &= \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n+  1} \right]  + \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n}  \right]  \\
f''\left( x \right) &= f'\left( x \right)+  f\left( x \right)
\end{align*}


Using the theory of higher order linear differential equations with
constant coefficients it can be shown:


\begin{align*}
f\left( x \right)= c_1 \cdot  \mathrm{exp}\left[ \left( \frac{1- \sqrt{5} }{2} \right)x \right] +  c_2 \cdot  \mathrm{exp}\left[ \left( \frac{1 +  \sqrt{5} }{2} \right) \right]
\end{align*}


By equating this to the power series:


\begin{align*}
f\left( x \right)&= \sum^{\infty}_{n= 0}   \left[ \left( c_1\left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+ \sqrt{5} }{2} \right)^n \right) \cdot  \frac{x^n}{n} \right]
\end{align*}


Now given that:


\begin{align*}
f\left( x \right)= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]
\end{align*}


We can conclude that:


\begin{align*}
a_n = c_1\cdot  \left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+  \sqrt{5} }{2} \right)
\end{align*}


By applying the initial conditions:


\begin{align*}
a_0= c_1 +  c_2  \implies  c_1= - c_2\\
a_1= c_1 \left( \frac{1+ \sqrt{5} }{2} \right) -  c_1 \frac{1-\sqrt{5} }{2}  \implies  c_1 = \frac{1}{\sqrt{5} }
\end{align*}


And so finally we have the solution to the /Fibonacci Sequence/ ref:eq:fib-def-shift:


\begin{align}
    a_n &= \frac{1}{\sqrt{5} } \left[ \left( \frac{1+  \sqrt{5} }{2}  \right)^n -  \left( \frac{1- \sqrt{5} }{2} \right)^n \right] \nonumber \\
&= \frac{\varphi^n - \psi^n}{\sqrt{5} } \nonumber\\
&=\frac{\varphi^n -  \psi^n}{\varphi - \psi} \label{eq:fib-sol}
\end{align}


where:

- $\varphi = \frac{1+ \sqrt{5} }{2} \approx 1.61\ldots$
- $\psi = 1-\varphi = \frac{1- \sqrt{5} }{2} \approx 0.61\ldots$

*** Derivative of the Exponential Generating Function
    :PROPERTIES:
    :CUSTOM_ID: Derivative-exp-gen-function
    :END:
    Differentiating the exponential generating function has the effect of shifting the sequence to the backward: cite:lehmanReadingsMathematicsComputer2010

\begin{align}
    f\left( x \right) &= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right] \label{eq:exp-pow-series} \\
f'\left( x \right)) &= \frac{\mathrm{d} }{\mathrm{d} x}\left( \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]  \right) \nonumber \\
&= \frac{\mathrm{d}}{\mathrm{d} x} \left( a_0 \frac{x^0}{0!} +  a_1 \frac{x^1}{1!} +  a_2 \frac{x^2}{2!}+  a_3 \frac{x^3}{3! } +  \ldots \frac{x^k}{k!} \right) \nonumber \\
&= \sum^{\infty}_{n= 0}   \left[ \frac{\mathrm{d} }{\mathrm{d} x}\left( a_n \frac{x^n}{n!} \right) \right] \nonumber \\
&= \sum^{\infty}_{n= 0}   {\left[{ \frac{a_n}{{\left({ n- 1 }\right)!}} } x^{n- 1}  \right]} \nonumber \\
\implies f'(x) &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}a_{n+  1} }\right]} \label{eq:exp-pow-series-sol}
\end{align}

If $f\left( x \right)= \sum^{\infty}_{n= 0 } \left[ a_n \frac{x^n}{n!} \right]$ can it be shown by induction that $\frac{\mathrm{d}^k }{\mathrm{d} x^k} \left(  f\left( x \right) \right)= f^{k} \left( x \right) \sum^{\infty}_{n= 0}   \left[ x^n \frac{a_{n+  k}}{n!} \right]$

*** TODO Homogeneous Proof
An equation of the form:

\begin{align}
\sum^{\infty}_{n=0} \left[ c_{i} \cdot f^{(n)}(x) \right] = 0 \label{eq:hom-ode}
\end{align}

is said to be a homogenous linear ODE: [[cite:zillDifferentialEquations2009a][Ch. 2]]

- Linear :: because the equation is linear with respect to $f(x)$
- Ordinary :: because there are no partial derivatives (e.g. $\frac{\partial }{\partial x}{\left({ f{\left({ x }\right)} }\right)}$  )
- Differential :: because the derivates of the function are concerned
- Homogenous :: because the */RHS/* is 0
  - A non-homogeous equation would have a non-zero RHS

There will be $k$ solutions to a $k^{\mathrm{th}}$ order linear ODE, each may be summed to produce a superposition which will also be a solution to the equation, [[cite:zillDifferentialEquations2009a][Ch. 4]]  this will be considered as the desired complete solution (and this will be shown to be the only solution for the recurrence relation eqref:eq:recurrence-relation-def). These $k$ solutions will be in one of two forms:

1. $f(x)=c_{i} \cdot e^{m_{i}x}$
2. $f(x)=c_{i} \cdot x^{j}\cdot e^{m_{i}x}$

where:

- $\sum^{k}_{i=0}\left[  c_{i}m^{k-i} \right] = 0$
  - This is referred to the characteristic equation of the recurrence relation or ODE cite:levinSolvingRecurrenceRelations2018
- $\exists i,j \in \mathbb{Z}^{+} \cap \left[0,k\right]$
  - These is often referred to as repeated roots cite:levinSolvingRecurrenceRelations2018,zillMatrixExponential2009 with a multiplicity corresponding to the number of repetitions of that root [[cite:nicodemiIntroductionAbstractAlgebra2007][\textsection 3.2]]

**** Unique Roots of Characteristic Equation
:PROPERTIES:
:CUSTOM_ID: uniq-roots-recurrence
:END:
***** Example
An example of a recurrence relation with all unique roots is the fibonacci sequence, as described in section [[#solving-the-sequence]].
***** Proof
Consider the linear recurrence relation eqref:eq:recurrence-relation-def:

\begin{align}
\sum^{\infty}_{n= 0}   \left[ c_i \cdot  a_n \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+ \nonumber
\end{align}

By implementing the exponential generating function as shown in eqref:eq:exp-gen-def-1, this provides:


\begin{align}
    \sum^{k}_{i= 0}   {\left[{ c_i \cdot a_n } \right]} = 0 \nonumber \\
    \intertext{By Multiplying through and summing: } \notag \\
     \implies  \sum^{k}_{i= 0}   {\left[{ \sum^{\infty}_{n= 0}   {\left[{ c_i a_n \frac{x^n}{n!} }\right]}  }\right]}  \nonumber = 0 \\
     \sum^{k}_{i= 0}    {\left[{ c_i \sum^{\infty}_{n= 0}   {\left[{  a_n \frac{x^n}{n!} }\right]}  }\right]}  \nonumber = 0 \\
\end{align}

Recall from eqref:eq:exp-gen-def-1 the generating function $f{\left({ x }\right)}$:

\begin{align}
\sum^{k}_{i= 0}   {\left[{ c_i f^{{\left({ k }\right)} } } {\left({ x }\right)} \right]} \label{eq:exp-gen-def-proof}  &= 0
\end{align}


Now assume that the solution exists and all roots of the characteristic polynomial are unique (i.e. the solution is of the form $f{\left({ x }\right)} \propto e^{m_i x}: \quad m_i \neq m_j \forall i\neq j$), this implies that  [[cite:zillDifferentialEquations2009a][Ch. 4]] :

\begin{align}
    f{\left({ x }\right)} = \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x} }\right]}, \quad \exists m,k \in \mathbb{C} \nonumber
\end{align}

This can be re-expressed in terms of the exponential power series, in order to relate the solution of the function $f{\left({ x }\right)}$ back to a solution of the sequence $a_n$, (see section [[#prove-exp-power-series]] for a derivation of the exponential power series):

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x}  }\right]}  &= \sum^{k}_{i= 0}   {\left[{ k_i \sum^{\infty}_{n= 0}   \frac{{\left({ m_i x }\right)}^n}{n!}  }\right]}  \nonumber \\
							 &= \sum^{k}_{i= 0}  \sum^{\infty}_{n= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber\\
							 &=    \sum^{\infty}_{n= 0} \sum^{k}_{i= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber \\
							 &= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}, \quad \exists k_i \in \mathbb{C}, \enspace \forall i \in \mathbb{Z}^+\cap {\left[{ 1, k }\right]}     \label{eq:unique-root-sol-power-series-form}
\end{align}

Recall the definition of the generating function from ref:eq:exp-gen-def-proof, by relating this to eqref:eq:unique-root-sol-power-series-form:

\begin{align}
    f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{  \frac{x^n}{n!} a_n }\right]} \nonumber \\
&= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}  \nonumber \\
      \implies  a_n &= \sum^{k}_{n= 0} {\left[{ k_im_i^n }\right]}     \nonumber \\ \nonumber
\square
\end{align}

This can be verified by the fibonacci sequence as shown in section [[#solving-the-sequence]], the solution to the characteristic equation is $m_1 = \varphi, m_2 = {\left({ 1-\varphi }\right)}$ and the corresponding solution to the linear ODE and recursive relation are:

\begin{alignat}{4}
    f{\left({ x }\right)} &= &c_1 e^{\varphi x} +  &c_2 e^{{\left({ 1-\varphi }\right)} x}, \quad &\exists c_1, c_2 \in \mathbb{R} \subset \mathbb{C} \nonumber \\
    \iff  a_n &= &k_1 n^{\varphi} +  &k_2 n^{1- \varphi}, &\exists k_1, k_2 \in \mathbb{R} \subset \mathbb{C} \nonumber
\end{alignat}

**** Repeated Roots of Characteristic Equation
:PROPERTIES:
:CUSTOM_ID: rep-roots-recurrence
:END:
***** Example
Consider the following recurrence relation:

\begin{align}
    a_n -  10a_{n+ 1} +  25a_{n+  2}&= 0 \label{eq:hom-repeated-roots-recurrence} \\
    \implies  \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} - 10 \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}+    }\right]} + 25 \sum^{\infty}_{n= 0 }   {\left[{  a_{n+  2 }\frac{x^n}{n!} }\right]}&= 0 \nonumber
\end{align}

By applying the definition of the exponential generating function at eqref:eq:exp-gen-def-1 :

\begin{align}
    f''{\left({ x }\right)}- 10f'{\left({ x }\right)}+  25f{\left({ x }\right)}= 0 \nonumber \label{eq:rep-roots-func-ode}
\end{align}

By implementing the already well-established theory of linear ODE's, the characteristic equation for eqref:eq:rep-roots-func-ode can be expressed as:

\begin{align}
    m^2- 10m+  25 = 0 \nonumber \\
    {\left({ m- 5 }\right)}^2 = 0 \nonumber \\
    m= 5 \label{eq:rep-roots-recurrence-char-sol}
\end{align}

Herein lies a complexity, in order to solve this, the solution produced from eqref:eq:rep-roots-recurrence-char-sol can be used with the /Reduction of Order/ technique to produce a solution that will be of the form [[cite:zillMatrixExponential2009][\textsection 4.3]].

\begin{align}
    f{\left({ x }\right)}= c_1e^{5x} +  c_2 x e^{5x} \label{eq:rep-roots-ode-sol}
\end{align}

eqref:eq:rep-roots-ode-sol can be expressed in terms of the exponential power series in order to try and relate the solution for the function back to the generating function,
observe however the following power series identity (TODO Prove this in section [[#prove-ext-exp-power-series-rep-roots]]):

\begin{align}
    x^ke^x &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}, \quad \exists k \in \mathbb{Z}^+ \label{eq:uniq-roots-pow-series-ident}
\end{align}

by applying identity eqref:eq:uniq-roots-pow-series-ident to equation eqref:eq:rep-roots-ode-sol

\begin{align}
    \implies  f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{ c_1 \frac{{\left({ 5x }\right)}^n}{n!} }\right]}  +  \sum^{\infty}_{n= 0}   {\left[{ c_2 n \frac{{\left({ 5x^n }\right)}}{n{\left({ n-1 }\right)}!} }\right]} \nonumber \\
 &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!} {\left({ c_{1}5^n +  c_2 n 5^n   }\right)} }\right]} \nonumber
\end{align}

Given the defenition of the exponential generating function from eqref:eq:exp-gen-def-1

\begin{align}
    f{\left({ x }\right)}&=     \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} \nonumber \\
    \iff a_n &= c_{15}^n +  c_2n_5^n \nonumber \\ \nonumber
    \ \nonumber \\
    \square \nonumber
\end{align}
***** Generalised Example

***** TODO Proof
In order to prove the the solution for a $k^{\mathrm{th}}$ order recurrence relation with $k$ repeated


Consider a recurrence relation of the form:

\begin{align}
     \sum^{k}_{n= 0}   {\left[{ c_i a_n }\right]}  = 0 \nonumber \\
      \implies  \sum^{\infty}_{n= 0}   \sum^{k}_{i= 0}   c_i a_n \frac{x^n}{n!} = 0 \nonumber \\
      \sum^{k}_{i= 0}   \sum^{\infty}_{n= 0}   c_i a_n \frac{x^n}{n!} \nonumber
\end{align}

By substituting for the value of the generating function (from eqref:eq:exp-gen-def-1):

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ c_if^{{\left({ k }\right)}}  {\left({ x }\right)}    }\right]} \label{eq:gen-form-rep-roots-ode}
\end{align}

Assume that eqref:eq:gen-form-rep-roots-ode corresponds to a charecteristic polynomial with only 1 root of multiplicity $k$, the solution would hence be of the form:

\begin{align}
			 & \sum^{k}_{i= 0}   {\left[{ c_i m^i }\right]} = 0 \wedge m=B, \enspace  \exists! B \in \mathbb{C} \nonumber \\
 \implies      f{\left({ x }\right)}&= \sum^{k}_{i= 0}   {\left[{ x^i A_i e^{mx} }\right]}, \quad \exists A \in \mathbb{C}^+, \enspace \forall i \in {\left[{ 1,k }\right]} \cap \mathbb{N}  \label{eq:sol-rep-roots-ode} \\
\end{align}

Recall the following power series identity (proved in section xxx):

\begin{align}
x^k e^x = \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}     \nonumber
\end{align}

By applying this to eqref:eq:sol-rep-roots-ode :

\begin{align}
f{\left({ x }\right)}&=     \sum^{k}_{i= 0}   {\left[{ A_i \sum^{\infty}_{n= 0}   {\left[{ \frac{{\left({ x m }\right)}^n}{{\left({ n- i }\right)}!} }\right]}  }\right]} \nonumber \\
&=     \sum^{\infty}_{n= 0}   {\left[{ \sum^{k}_{i=0} {\left[{ \frac{x^n}{n!}  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]} # \\
&=     \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}   \sum^{k}_{i=0} {\left[{  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]}
\end{align}

Recall the generating function that was used to get ref:eq:gen-form-rep-roots-ode:

\begin{align}
f{\left({ x }\right)}&= \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]}      \nonumber \\
 \implies  a_n &= \sum^{k}_{i= 0}   {\left[{ A_i \frac{n!}{{\left({ n- i }\right)}!} m^n  }\right]} \nonumber \\
 &= \sum^{k}_{i= 0}   {\left[{ m^n A_i \prod_{0}^{k} {\left[{ n- {\left({ i- 1 }\right)} }\right]}   }\right]}
& \intertext{$\because \enspace i \leq k$} \notag \\
 &= \sum^{k}_{i= 0} {\left[{ A_i^* m^n n^i }\right]}, \quad \exists A_i \in \mathbb{C}, \enspace \forall i\leqk \in \mathbb{Z}^+ \nonumber \\
\ \nonumber \\
\square \nonumber
\end{align}



**** TODO General Proof
In sections [[#uniq-roots-recurrence]] and [[*Unique Roots of Characteristic Equation]] it was shown that a recurrence relation can be related to an ODE and then that solution can be transformed to provide a solution for the recurrence relation, when the charecteristic polynomial has either complex roots or 1 repeated root. Generally the solution to a linear ODE will be a superposition of solutions for each root, repeated or unique and so here it will be shown that these two can be combined and that the solution will still hold.

Consider a Recursive relation with constant coefficients:

$$
\sum^{\infty}_{n= 0}   \left[ c_i \cdot  a_n \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+
$$

This can be expressed in terms of the exponential generating function:

$$
\sum^{\infty}_{n= 0}   \left[ c_i \cdot  a_n \right] = 0\\
\implies \sum^{\infty}_{n= 0}   \left[\sum^{\infty}_{n= 0}   \left[ c_i \cdot
a_n  \right]   \right] = 0
$$

- Use the Generating function to get an ODE
- The ODE will have a solution that is a combination of the above two forms
- The solution will translate back to a combination of both above forms

** Fibonacci Sequence and the Golden Ratio
:PROPERTIES:
:CUSTOM_ID: fib-golden-ratio-proof
:END:
The /Fibonacci Sequence/ is actually very interesting, observe that the ratios of the terms converge to the /Golden Ratio/:

\begin{align*}
    F_n &= \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5} \\
    \iff \frac{F_{n+1}}{F_n}	&= \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \\
    \iff \lim_{n \rightarrow \infty}\left[ \frac{F_{n+1}}{F_n} \right]	&= \lim_{n \rightarrow \infty}\left[ \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \right] \\
&= \frac{\varphi^{n+ 1} -\lim_{n \rightarrow \infty}\left[ \psi^{n +  1} \right] }{\varphi^{n} - \lim_{n \rightarrow \infty}\left[ \psi^n \right] } \\
\text{because $\mid \psi \mid < 0$ $n \rightarrow \infty \implies \psi^{n} \rightarrow 0$:} \\
&= \frac{\varphi^{n+  1} -  0}{\varphi^{n} -  0} \\
&= \varphi
\end{align*}

We'll come back to this later on when looking at spirals and fractals.

This can also be shown by using analysis, let $L=\lim_{n \rightarrow \infty} \left[ \frac{F_{n+1}}{F_{n}} \right], then:

* Persian Recursion
** What is it?
This is a simple process that produces complex structured patterns in response
to feedback and iteration.

1. Decide on some four variable function to describe a set of colours, e.g.:
   a. $f(w,x,y,z)=(w+x+y+z) \mod m$
2. Assign this value to the centre row and centre column of a matrix
3. Repeat this for each newly enclosed sub-matrix.

** Implementing with Python
*** Plan of Attack

This can be implemented computationally by defining a function that:

- takes the index of four corners enclosing a square sub-matrix of some matrix as input,
- proceeds only if that square is some positive real value.
- colours the centre column and row corresponding to a function of those four values
- then calls itself on the corners of the four new sub-matrices enclosed by the
  coloured row and column

*** Implementation

#+NAME: persian-recursion-python
#+CAPTION: Implementation of the persian recursion scheme in /Python/
#+BEGIN_SRC ipython :exports both :results raw drawer :eval never-export :session persian-recursion :ipyfile ./persian-recursion-0.svg
%matplotlib inline
# m is colours
# n is number of folds
# Z is number for border
# cx is a function to transform the variables
def main(m, n, z, cx):
    import numpy as np
    import matplotlib.pyplot as plt

    # Make the Empty Matrix
    mat = np.empty([2**n+1, 2**n+1])
    main.mat = mat

    # Fill the Borders
    mat[:,0] = mat[:,-1] = mat[0,:] = mat[-1,:] = z

    # Colour the Grid
    colorgrid(0, mat.shape[0]-1, 0, mat.shape[0]-1, m)

    # Plot the Matrix
    plt.matshow(mat)

# Define Helper Functions
def colorgrid(l, r, t, b, m):
    # print(l, r, t, b)
    if (l < r -1):
        ## define the centre column and row
        mc = int((l+r)/2); mr = int((t+b)/2)

        ## Assign the colour
        main.mat[(t+1):b,mc] = cx(l, r, t, b, m)
        main.mat[mr,(l+1):r] = cx(l, r, t, b, m)

        ## Now Recall this function on the four new squares
                #l r   t   b
        colorgrid(l, mc, t, mr, m)    # NW
        colorgrid(mc, r, t, mr, m)    # NE
        colorgrid(l, mc, mr, b, m)    # SW
        colorgrid(mc, r, mr, b, m)    # SE

def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r] +  main.mat[b,l] + main.mat[b,r]) % m
    return new_col.astype(int)

main(5,6, 1, cx)
#+end_src

** The Output

*** 6 Folds
#+attr_html: :width 400px
#+attr_latex: :width 6cm
#+NAME: 6-rug
#+CAPTION: Output produced by listing [[persian-recursion-python]] with 6 folds
[[file:../persian-recursion-0.svg]]
*** 9 Folds

#+NAME: 8-fold-code
#+CAPTION: Modify listing [[persian-recursion-python]] to create 9 folds
#+BEGIN_SRC ipython :exports output :results raw :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-large.svg
%config InlineBackend.figure_format = 'svg'
main(5, 9, 1, cx)
#+END_SRC

#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: 8-fold-plot
#+CAPTION: Output produced by listing [[persian-recursion-python]] with 9 folds
[[file:~/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/persian-recursion-large.svg]]

*** Different Function
#+NAME: new-func-code
#+BEGIN_SRC ipython :exports both :results raw drawer :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-new-func.svg
%config InlineBackend.figure_format = 'svg'
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r] +  main.mat[b,l] + main.mat[b,r]-7) % m
    return new_col.astype(int)
main(8, 8, 1, cx)
#+END_SRC

#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: new-func-plot
#+CAPTION: Output produced by listing [[new-func-code]] using $f(w,x,y,z) = (w + x + y + z - 7) \mod 8$
#+RESULTS: new-func-code
[[file:../persian-recursion-new-func.svg]]

*** Different Function

#+NAME: new-func2-code
#+BEGIN_SRC ipython :exports both :results raw drawer :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-new-func2.svg
%config InlineBackend.figure_format = 'svg'
import numpy as np
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r]*m +  main.mat[b,l]*(m) + main.mat[b,r]*(m))**1 % m + 1
    return new_col.astype(int)
main(8, 8, 1, cx)
#+END_SRC


#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: new-func2-plot
#+CAPTION: Output produced by listing [[new-func2-code]] using $f(w,x,y,z) = (w + 8x + 8y + 8z) \mod 8 + 1$
#+RESULTS: new-func2-code
[[file:../persian-recursion-new-func2.svg]]

** Emergence of Patterns
:PROPERTIES:
:ID:       c33e2a2b-7dd1-4c5b-a3e2-7a84b0878407
:DIR:      /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/Slides/attachments/
:END:

Many patterns that occur in nature can be explained by relatively simple rules
that are exposed to feedback and iteration, this is a centreal theme of Alan
Turing's /The Chemical Basis For Morphogenesis/ which we hope to look in the
course of this research.


#+attr_html: :width 400px
#+attr_latex: :width 9cm
[[attachment:_20200826_172316screenshot.png]]

* Julia Sets
** Motivation
*** The Problem
- Consider the iterative process $x \rightarrow x^{2}, \enspace x \in \mathbb{R}$,
  - $x\leq 1 \implies$ convergence
  - $x>1 \implies$ divergence
- Now Consider the iterative process $z \rightarrow z^{2}, \enspace z \in \mathbb{C}$,
  - $\left\lvert z  \right \rvert  \leq 1 \implies$ convergence
  - $\left\lvert z  \right \rvert   >1 \implies$ divergence

*** The Generalisation
Although this seems trivial this can be generalised.

Consider:

$$f_{c}(z) = z^{2} + c, \quad \left\lvert c  \right \rvert  \left\lvert z  \right \rvert   \leq 1 \in \mathbb{C}$$




Every value on that plane will belong to one of the two following sets:

- $E_{c}$ :: The set of values on the plane that tend to $\infty$ (escapees)
- $P_{c}$ :: The set of values on the plane that converge to zero (prisoners)

#+REVEAL: split

- Define $Q^{(k)}_{c}$ to be the the set of values confirmed as prisoners after $k$ iterations of $f_{c}$
    - this implies $\lim_{k \rightarrow \infty} \left[ Q^{(k)}_{c}  \right] = P_{c}$

$$
\ \\ \\
$$
This is what must be used in practice.
** Plotting the Sets
:PROPERTIES:
:ID:       baa21085-5d8f-4390-9bb7-43c3b51d940d
:END:
*** Implementing this

To implement this map a function over the elements of a matrix and map that
matrix to the complex plane, this will produce a matrix of values (this is a
picture!)

- ~escape_test~ :: applies iteration until divergence or convergence
  + Divergence is concluded if $z > \max{2, c}$, and convergence is conceded some number of iterations.

*** The Code
**** Defining Complex Values

#+NAME: complex-vec
#+CAPTION: Defining Complex Operations with vectors
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export
from math import sqrt
def magnitude(z):
    # return sqrt(z[0]**2 + z[1]**2)
    x = z[0]
    y = z[1]
    return sqrt(sum(map(lambda x: x**2, [x, y])))

def cAdd(a, b):
    x = a[0] + b[0]
    y = a[1] + b[1]
    return [x, y]


def cMult(u, v):
    x = u[0]*v[0]-u[1]*v[1]
    y = u[1]*v[0]+u[0]*v[1]
    return [x, y]
#+end_src

#+RESULTS: complex-vec

**** Coding the Julia Set

#+NAME: py-circle-code
#+CAPTION: Circle of Convergence of $z$ under recursion
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export :ipyfile ./circle-of-convergence.svg
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
import numpy as np
def escape_test(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    c = [0, 0]
    count = 0
    z1 = z  #Remember the original value that we are working with
    # Iterate num times
    while count <= num:
        dist = sum([n**2 for n in z1])
        distc = sum([n**2 for n in c])
        # check for divergence
        if dist > max(2, distc):
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1), c)
        count+=1
        #if z hasn't diverged by the end
    return num



p = 0.25 #horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = escape_test(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt

plt.axis('off')
plt.imshow(pic)
# plt.show()

#+end_src

#+REVEAL: split


#+NAME: py-circle-plot
#+attr_html: :width 600px
#+attr_latex: :width 9cm
#+RESULTS: py-circle-code
[[file:./circle-of-convergence.svg]]

Now at this stage nothing's remarkable, obviously it's a circle, when we
perform $z \rightarrow z^{2}$ values converge for $\left\lvert z  \right \rvert \leq 1$.

#+REVEAL: split

But what if we try something like:

\begin{align}
f_{\frac{1}{4} + \frac{i}{2}}&: z \rightarrow z^{2} + (\frac{1}{4} + \frac{i}{2}) \\
f_{-1}&: z \rightarrow z^{2} - 1
\end{align}

#+REVEAL: split

#+attr_html: :width 800px
#+attr_latex: :width 9cm
#+NAME: py-jl-rab-plot
#+CAPTION: Circle of Convergence for $f_{\frac{1}{4} + \frac{i}{2}}: z \rightarrow z^{2} + \frac{1}{4} + \frac{i}{2}$
[[file:./julia-rab.svg]]


#+REVEAL: split

#+attr_html: :width 800px
#+attr_latex: :width 9cm
#+NAME: py-jl-1-plot
#+CAPTION: Circle of Convergence for $f_{0}: z \rightarrow z^{2} - 1$
[[file:./julia-1.svg]]

*** Broader Investigation
**** Approach
Consider the equation:
$$
f_{0.8 e^{\pi i \tau}}: z \rightarrow z^{2} + 0.8 e^{\pi
i \tau}, \enspace \tau \in \mathbb{R}
$$

If the value $\tau$ is iterated over some range a series of snapshots can be
created.
**** Code
/Python/ is too slow, I had to instead use /Julia/ and I produced and this how
im implemented it:

#+NAME: julia-gen-fracs
#+CAPTION: Produce a series of fractals using julia
#+begin_src julia
# * Define the Julia Set
"""
Determine whether or not a value will converge under iteration
"""
function juliaSet(z, num, my_func)
    count = 1
    # Remember the value of z
    z1 = z
    # Iterate num times
    while count ‚â§ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) # + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

# * Make a Picture
"""
Loop over a matrix and apply apply the julia-set function to
the corresponding complex value
"""
function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    zoom = 0.3
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = (j-width/2)/(width*zoom)
            y = (i-height/2)/(height*zoom)
            pic_mat[i,j] = juliaSet(x+y*im, 256, my_func)
        end
    end
    return pic_mat
end

#+end_src

#+REVEAL: split

To save the images I looped over the function and saved.

#+NAME: GR-save
#+CAPTION: Generate and save the images with GR
#+begin_src julia
# * Use GR to Save a Bunch of Images
  ## GR is faster than PyPlot
using GR
function save_images(count, res)
    try
        mkdir("/tmp/gifs")
    catch
    end
    j = 1
    for i in (1:count)/(40*2*œÄ)
        j = j + 1
        GR.imshow(make_picture(res, res, z -> z^2 + 0.8*exp(i*im*9/2))) # PyPlot uses interpolation = "None"
        name = string("/tmp/gifs/j", lpad(j, 5, "0"), ".png")
        GR.savefig(name)
    end
end

save_images(1200, 1500) # Number  and Res
#+end_src
**** Viewing the Results
***** What we Have                                                          :ATTACH:
:PROPERTIES:
:DIR:      /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/Slides/attachments/
:END:
We just have a bunch of images now:


#+attr_html: :width 800px
#+attr_latex: :width 9cm
[[attachment:_20200826_223550screenshot.png]]

***** How to work with it

With /ImageMagick/ and ~ffmpeg~ an animation can be produced, here's how

#+NAME: bash-frac-join
#+CAPTION: Using ~bash~, ~ffmpeg~ and /ImageMagick/ to combine the images and produce an animation.
#+begin_src bash
# Use montage multiple times to get recursion for fun
montage  (ls *png | sed -n '1p;0~600p') 0a.png
montage (ls *png | sed -n '1p;0~100p') a.png
montage -geometry 1000x1000 (ls *png | sed -n '1p;0~50p')  a.png

# Use ImageMagick to Produce a gif (unreliable)
convert -delay 10 *.png 0.gif

# Use FFMpeg to produce a Gif instead
ffmpeg                    \
    -framerate 60         \
    -pattern_type glob    \
    -i '*.png'            \
    -r 15                 \
    out.mov


#+end_src

***** Montage
:PROPERTIES:
:DIR:      /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/Slides/attachments/
:END:


#+attr_html: :width 1000px
#+attr_latex: :width 9cm
#+NAME: montage-frac
#+CAPTION: Various fracals corresponding to $f_{0.8 e^{\pi i \tau}}$
[[attachment:_20200826_005334a.png]]

***** Gif

#+attr_html: :width 1200px
#+attr_latex: :width 9cm
[[https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0]]


*** The *Why*?
- These shapes and patterns occur in nature all the time
  + Math is somewhat the science of patterns
- It's fun

* MandelBrot Set
** Motivation
Notice that some of prisoner sets were closed and some were open? A natural
question arises:

/for which values of $c$ will they be open and for which values will they be closed?/

It can be shown (and I intend to show it generally), that the distribution of
these values is equivallent to the julia set where:

$$
f_{\gamma}: z -> z^{2} + \gamma \enspace : \enspace \gamma = z
$$

*** Implementing This

Implementing this in /Python/ is pretty much the same as before but some care
needs to be taken with respect to storing $z$ as a constant to use in place of
$c$

#+NAME: py-mandelbrot-code
#+CAPTION: All values of $c$ that lead to a closed /Julia-set/
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export :ipyfile ./mandelbrot-py.svg
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
def mandelbrot(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    count = 0
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count <= num:
        # check for divergence
        if magnitude(z1) > 2.0:
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1),z)
        count+=1
        #if z hasn't diverged by the end
    return num

import numpy as np


p = 0.25 # horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = mandelbrot(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt
plt.imshow(pic)
# plt.show()
#+end_src

**** Output Set


#+attr_html: :width 800px
#+attr_latex: :width 9cm
#+RESULTS: py-mandelbrot-code
[[file:./mandelbrot-py.svg]]

*** Push the envelope

This is however fairly underwhelming, by using a more powerful language a much
larger image can be produced, in /Julia/ producing a 4 GB, 400 MP image will
take about 10 minutes

**** Code

#+NAME:
#+begin_src julia
function mandelbrot(z, num, my_func)
    count = 1
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count ‚â§ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = j/width
            y = i/height
            pic_mat[i,j] = mandelbrot(x+y*im, 99, my_func)
        end
    end
    return pic_mat
end


using FITSIO
function save_picture(filename, matrix)
    f = FITS(filename, "w");
    # data = reshape(1:100, 5, 20)
    # data = pic_mat
    write(f, matrix)  # Write a new image extension with the data

    data = Dict("col1"=>[1., 2., 3.], "col2"=>[1, 2, 3]);
    write(f, data)  # write a new binary table to a new extension

    close(f)
end

# * Save Picture
#------------------------------------------------------------
my_pic = make_picture(20000, 20000, z -> z^2) 2000^2 is 4 GB
save_picture("/tmp/a.fits", my_pic)

#+end_src

**** Visualisation of Set
I've taken some techniques from Astronomy and encoded the image as a /FITS/,
which is basically a big matrix, it image is [[https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0][available-online]] but I can show you
here:

#+begin_src bash
xdg-open /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Problems/Chaos/mandelbrot-400mpx.fits & disown
#+end_src

I tried to go bigger but ~AstroFits.JL~ would not write the file, I think this
has something to do with ~/tmp~ having a 15GB File restriction but I'm not sure.

** GNU Plot
*** What is GNUPlot
It's a Free (as in speech) visualisation library.

We can use it to map the time until convergence to the z-axis which also reveals interesting patterns.

All the following code was adapted from online sources, they correspond to an older release
and newer versions of GNUPlot:

- have a recursion limit
 - methods to loop functions

so one of our desires in this project is to visualise a much more detailed 3d
model in GNUPlot by modifying the code to use iteration as opposed to recursion.

**** Mandelbrot

#+NAME: gnuplot-mandelbrot-initial
#+CAPTION: Visualising the Mandelbrot set as a 3D surface Plot
#+BEGIN_SRC gnuplot :cache no :exports both :results output graphics :file one.svg :eval never-export
complex(x,y) = x*{1,0}+y*{0,1}
mandelbrot(x,y,z,n) = (abs(z)>2.0 || n>=200) ? \
                  n : mandelbrot(x,y,z*z+complex(x,y),n+1)

set xrange [-2:2]
set yrange [-2:2]
set logscale z
set isosample 240
set hidden3d
set contour
splot mandel(x,y,{0,0},0) notitle
#+end_src

#+REVEAL: split

#+RESULTS: gnuplot-mandelbrot-initial
[[file:one.svg]]


**** Julia


#+NAME: gnuplot-julia
#+CAPTION: Use GNUPlot to produce plot of  julia set
#+BEGIN_SRC gnuplot :exports both :results output graphics :file two.svg :eval never-export

complex(x,y) = x*{1,0}+y*{0,1}
julia(x,y,z,n) = (abs(z)>2.0 || k>=200) ? \
                  k : julia(x,y,z*z+complex(x,y),n+1)

set xrange [-1.5:1.5]
set yrange [-1.5:1.5]
set logscale z
set isosample 150
set hidden3d
set contour
a= 0.25
b= 0.75
splot mandel(a,b,complex(x,y),0) notitle
#+end_src

#+REVEAL: split

#+RESULTS[e065d7a76464baa900fc7f9562aea3913aa29980]: gnuplot-julia
[[file:two.svg]]



*** 2d Mandelbrot


#+NAME: flat-gnuplot
#+CAPTION: Flat Mandelbrot set built using rosetta code.
#+BEGIN_SRC gnuplot :cache yes :exports both :results output graphics :file three.svg :eval never-export
R = 2
k = 100
complex (x, y) = x * {1, 0} + y * {0, 1}
mandelbrot (z, z0, n) = n == k || abs (z) > R ? n : mandelbrot (z ** 2 + z0, z0, n + 1)
set samples 200
set isosamples 200
set pm3d map
set size square
splot [-2 : 2] [-2 : 2] mandelbrot (complex (0, 0), complex (x, y), 0) notitle
#+end_src

#+REVEAL: split

[[file:three.svg]]

** Again, why?

This self Similarity occurs all the time in nature, one of these is synthetic, can you spot it?

#+attr_html: :width 700px
#+attr_latex: :width 9cm
[[file:media/out.png]]

